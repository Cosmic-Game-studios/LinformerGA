<?php

namespace App\Http\Controllers;

use Illuminate\Support\Facades\File;
use Illuminate\Support\Str;

class ErrorLogController extends Controller
{
    public function index()
    {
        $path = storage_path('logs/laravel.log');

        if (!File::exists($path)) {
            return view('errorlog.index', ['entries' => []]);
        }

        // --- vollständige Datei holen (max. 5 MB als pragmatische Obergrenze) ---
        $data = File::size($path) > 5 * 1024 * 1024
            ? File::get($path, false, null, File::size($path) - 5 * 1024 * 1024) // tail ≈ 5 MB
            : File::get($path);

        $lines   = preg_split('/\R/', $data);
        $pattern = '/^\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\]/';   // Zeilen-Header

        $entries = [];
        $current = ['header' => '', 'body' => []];

        foreach ($lines as $line) {
            if (preg_match($pattern, $line)) {          // neue Log-Nachricht
                if ($current['header']) {               // vorigen Block abschließen
                    $entries[] = $this->parseEntry($current);
                }
                $current = ['header' => $line, 'body' => []];
            } else {
                $current['body'][] = $line;
            }
        }
        // letzten Block hinzufügen
        if ($current['header']) {
            $entries[] = $this->parseEntry($current);
        }

        // jüngste Einträge zuerst
        $entries = array_reverse($entries);

        return view('errorlog.index', compact('entries'));
    }

    protected function parseEntry(array $raw): array
    {
        // Split header: [date] ENV.LEVEL: message
        if (preg_match('/^\[(.*?)\]\s+([^\:]+):\s*(.*)$/', $raw['header'], $m)) {
            $datetime = $m[1];
            $level    = $m[2];
            $summary  = $m[3];
        } else {
            // Fallback
            $datetime = '';
            $level    = 'INFO';
            $summary  = $raw['header'];
        }

        // Bootstrap-Badge nach Log-Level
        $badge = Str::contains($level, 'ERROR')   ? 'danger'
               : (Str::contains($level, 'WARNING')? 'warning'
               : (Str::contains($level, 'CRITICAL')? 'danger'
               : 'secondary'));

        return [
            'datetime' => $datetime,
            'level'    => $level,
            'badge'    => $badge,
            'summary'  => $summary,
            'full'     => trim($raw['header']."\n".implode("\n", $raw['body'])),
        ];
    }
}