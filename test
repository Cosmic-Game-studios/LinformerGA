<?php

namespace Modules\Admin\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Response;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Str;
use Carbon\Carbon;
use SplFileObject;

class ErrorLogController
{
    private string $logDir;
    private string $currentFile = '';
    private int $maxTailLines = 50000; // Erhöht für bessere Abdeckung

    public function __construct()
    {
        $this->logDir = rtrim(
            base_path('storage' . DIRECTORY_SEPARATOR . 'logs'),
            '\\/'
        ) . DIRECTORY_SEPARATOR;

        abort_unless(is_dir($this->logDir), 500, "Log-Verzeichnis fehlt: {$this->logDir}");
    }

    public function index(Request $request)
    {
        // 1) Alle log-Dateien lesen und sortieren
        $files = collect(File::glob($this->logDir . 'laravel-*.log'))
            ->map(fn($p) => new \SplFileInfo($p))
            ->sortByDesc(fn($f) => $f->getMTime())
            ->values();

        // 2) availableDates für Sidebar
        $availableDates = $files
            ->map(function($f) {
                $filename = $f->getFilename();
                if (preg_match('/laravel-(\d{4}-\d{2}-\d{2})\.log/', $filename, $matches)) {
                    $date = $matches[1];
                } else {
                    $date = substr($filename, 8, 10);
                }
                
                return [
                    'date' => $date,
                    'size' => $f->getSize(),
                ];
            })
            ->filter(fn($item) => !empty($item['date']) && preg_match('/^\d{4}-\d{2}-\d{2}$/', $item['date']))
            ->unique('date')
            ->sortByDesc('date')
            ->values();

        // 3) Aktuelles Datum / Datei
        $dateParam = $request->query('date', $availableDates->first()['date'] ?? null);
        if (! $dateParam || ! $availableDates->firstWhere('date', $dateParam)) {
            $dateParam = $availableDates->first()['date'] ?? null;
        }
        $this->currentFile = "laravel-{$dateParam}.log";

        // 4) Existenz-Check
        $path = $this->logDir . $this->currentFile;
        abort_unless(File::isFile($path), 404);

        // 5) Filter-Parameter
        $level = $request->query('level', 'all');
        $search = $request->query('search', '');
        $fromTime = $request->query('from_time', '');
        $toTime = $request->query('to_time', '');
        $useRegex = $request->query('use_regex', false);
        $groupSimilar = $request->query('group_similar', false);
        
        // 6) per-page Options
        $perPageOptions = [25, 50, 100, 200, 500];
        $perPage = (int) $request->query('per_page', 100);
        if (! in_array($perPage, $perPageOptions, true)) {
            $perPage = 100;
        }

        // 7) Log-Einträge lesen und parsen
        $rawLines = $this->getTailLines($path, $this->maxTailLines);
        $parsedLogs = $this->parseLogEntries($rawLines);
        
        // 8) Filter anwenden
        $filteredLogs = $this->applyFilters($parsedLogs, [
            'level' => $level,
            'search' => $search,
            'from_time' => $fromTime,
            'to_time' => $toTime,
            'use_regex' => $useRegex,
        ]);

        // 9) Gruppierung (optional)
        if ($groupSimilar) {
            $filteredLogs = $this->groupSimilarErrors($filteredLogs);
        }

        // 10) Pagination
        $page = LengthAwarePaginator::resolveCurrentPage();
        $logs = new LengthAwarePaginator(
            $filteredLogs->forPage($page, $perPage),
            $filteredLogs->count(),
            $perPage,
            $page,
            ['path' => $request->url(), 'query' => $request->query()]
        );

        // 11) Statistiken
        $stats = $this->generateStats($parsedLogs);

        return view('admin::errorlog.index', [
            'availableDates'  => $availableDates,
            'currentDate'     => $dateParam,
            'currentFile'     => $this->currentFile,
            'perPage'         => $perPage,
            'perPageOptions'  => $perPageOptions,
            'logs'            => $logs,
            'stats'           => $stats,
            'filters'         => [
                'level' => $level,
                'search' => $search,
                'from_time' => $fromTime,
                'to_time' => $toTime,
                'use_regex' => $useRegex,
                'group_similar' => $groupSimilar,
            ]
        ]);
    }

    // Export-Funktionen
    public function export(Request $request)
    {
        $format = $request->query('format', 'csv');
        $dateParam = $request->query('date', '');
        
        if (empty($dateParam)) {
            return back()->withErrors(['error' => 'Datum ist erforderlich']);
        }

        $this->currentFile = "laravel-{$dateParam}.log";
        $path = $this->logDir . $this->currentFile;
        
        if (!File::isFile($path)) {
            return back()->withErrors(['error' => 'Log-Datei nicht gefunden']);
        }

        $rawLines = $this->getTailLines($path, $this->maxTailLines);
        $parsedLogs = $this->parseLogEntries($rawLines);
        
        // Filter anwenden
        $filteredLogs = $this->applyFilters($parsedLogs, [
            'level' => $request->query('level', 'all'),
            'search' => $request->query('search', ''),
            'from_time' => $request->query('from_time', ''),
            'to_time' => $request->query('to_time', ''),
            'use_regex' => $request->query('use_regex', false),
        ]);

        if ($format === 'csv') {
            return $this->exportCsv($filteredLogs, $dateParam);
        } elseif ($format === 'json') {
            return $this->exportJson($filteredLogs, $dateParam);
        }

        return back()->withErrors(['error' => 'Ungültiges Export-Format']);
    }

    private function parseLogEntries($rawLines): \Illuminate\Support\Collection
    {
        $entries = collect();
        $currentEntry = null;
        
        foreach ($rawLines as $lineNumber => $line) {
            $line = trim($line);
            if (empty($line)) continue;
            
            // Laravel Log-Format: [timestamp] environment.LEVEL: message
            if (preg_match('/^\[(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})\]\s+\w+\.([A-Z]+):\s*(.*)$/', $line, $matches)) {
                // Neuer Log-Eintrag
                if ($currentEntry) {
                    $entries->push($currentEntry);
                }
                
                $timestamp = $matches[1];
                $level = strtolower($matches[2]);
                $message = $matches[3];
                
                // Level-Mapping
                if (in_array($level, ['error', 'critical', 'emergency', 'alert'])) {
                    $level = 'error';
                } elseif (in_array($level, ['warning', 'warn'])) {
                    $level = 'warning';
                } else {
                    $level = 'info';
                }
                
                $currentEntry = [
                    'timestamp' => $timestamp,
                    'level' => $level,
                    'message' => $message,
                    'raw' => $line,
                    'stack_trace' => [],
                    'context' => [],
                    'line_number' => $lineNumber + 1,
                    'hash' => md5($message), // Für Gruppierung
                ];
            } elseif ($currentEntry && (
                str_starts_with($line, '#') || 
                str_starts_with($line, 'Stack trace:') ||
                str_contains($line, '.php:') ||
                str_contains($line, 'Exception') ||
                str_starts_with($line, '   at ')
            )) {
                // Stack-Trace-Zeile
                $currentEntry['stack_trace'][] = $line;
            } elseif ($currentEntry) {
                // Context-Zeile
                $currentEntry['context'][] = $line;
            }
        }
        
        if ($currentEntry) {
            $entries->push($currentEntry);
        }
        
        return $entries->reverse(); // Neueste zuerst
    }

    private function applyFilters($logs, $filters): \Illuminate\Support\Collection
    {
        return $logs->filter(function($entry) use ($filters) {
            // Level-Filter
            if ($filters['level'] !== 'all' && $entry['level'] !== $filters['level']) {
                return false;
            }
            
            // Zeit-Filter
            if (!empty($filters['from_time'])) {
                $entryTime = Carbon::parse($entry['timestamp']);
                $fromTime = Carbon::parse($filters['from_time']);
                if ($entryTime->lt($fromTime)) {
                    return false;
                }
            }
            
            if (!empty($filters['to_time'])) {
                $entryTime = Carbon::parse($entry['timestamp']);
                $toTime = Carbon::parse($filters['to_time']);
                if ($entryTime->gt($toTime)) {
                    return false;
                }
            }
            
            // Text-Suche
            if (!empty($filters['search'])) {
                $searchText = $filters['search'];
                $content = $entry['raw'] . ' ' . implode(' ', $entry['stack_trace']) . ' ' . implode(' ', $entry['context']);
                
                if ($filters['use_regex']) {
                    try {
                        if (!preg_match('/' . $searchText . '/i', $content)) {
                            return false;
                        }
                    } catch (\Exception $e) {
                        // Fallback auf normale Suche
                        if (stripos($content, $searchText) === false) {
                            return false;
                        }
                    }
                } else {
                    if (stripos($content, $searchText) === false) {
                        return false;
                    }
                }
            }
            
            return true;
        });
    }

    private function groupSimilarErrors($logs): \Illuminate\Support\Collection
    {
        $grouped = $logs->groupBy('hash');
        
        return $grouped->map(function($group) {
            $first = $group->first();
            $count = $group->count();
            $latest = $group->sortByDesc('timestamp')->first();
            
            return array_merge($first, [
                'count' => $count,
                'latest_occurrence' => $latest['timestamp'],
                'is_grouped' => true,
                'similar_entries' => $group->values()->toArray(),
            ]);
        })->values()->sortByDesc('latest_occurrence');
    }

    private function generateStats($logs): array
    {
        $total = $logs->count();
        $errors = $logs->where('level', 'error')->count();
        $warnings = $logs->where('level', 'warning')->count();
        $infos = $logs->where('level', 'info')->count();
        
        // Letzte 24 Stunden
        $last24h = $logs->filter(function($entry) {
            return Carbon::parse($entry['timestamp'])->isAfter(Carbon::now()->subDay());
        })->count();
        
        return [
            'total' => $total,
            'errors' => $errors,
            'warnings' => $warnings,
            'infos' => $infos,
            'last_24h' => $last24h,
            'error_rate' => $total > 0 ? round(($errors / $total) * 100, 1) : 0,
        ];
    }

    private function exportCsv($logs, $date)
    {
        $filename = "laravel-logs-{$date}.csv";
        $headers = [
            'Content-Type' => 'text/csv',
            'Content-Disposition' => "attachment; filename=\"{$filename}\"",
        ];

        $callback = function() use ($logs) {
            $file = fopen('php://output', 'w');
            fputcsv($file, ['Timestamp', 'Level', 'Message', 'Stack Trace']);
            
            foreach ($logs as $entry) {
                fputcsv($file, [
                    $entry['timestamp'],
                    strtoupper($entry['level']),
                    $entry['message'],
                    implode('\n', $entry['stack_trace'])
                ]);
            }
            fclose($file);
        };

        return Response::stream($callback, 200, $headers);
    }

    private function exportJson($logs, $date)
    {
        $filename = "laravel-logs-{$date}.json";
        $data = [
            'export_date' => Carbon::now()->toISOString(),
            'log_date' => $date,
            'total_entries' => $logs->count(),
            'entries' => $logs->values()->toArray()
        ];

        return Response::json($data)
            ->header('Content-Disposition', "attachment; filename=\"{$filename}\"");
    }

    public function download(Request $request)
    {
        $file = trim(basename($request->query('file', '')));
        $path = $this->logDir . $file;
        abort_unless(
            $file && Str::endsWith(Str::lower($file), '.log') && File::isFile($path),
            404
        );
        return Response::download($path, $file, ['Content-Type' => 'text/plain']);
    }

    public function clear()
    {
        $today = Carbon::today()->format('Y-m-d');
        collect(File::glob($this->logDir . '*.log'))
            ->filter(fn($p) => ! Str::contains($p, $today))
            ->each(fn($p) => File::delete($p));
        return back()->with('status', 'Alle älteren Log-Dateien wurden gelöscht.');
    }

    protected function getTailLines(string $path, int $maxLines = 1000): array
    {
        $file = new SplFileObject($path, 'r');
        $file->seek(PHP_INT_MAX);
        $last = $file->key();
        if ($last < $maxLines) {
            $file->rewind();
            return iterator_to_array($file, false);
        }
        $file->seek(max(0, $last - $maxLines));
        $lines = [];
        while (! $file->eof()) {
            $lines[] = $file->current();
            $file->next();
        }
        return $lines;
    }
}